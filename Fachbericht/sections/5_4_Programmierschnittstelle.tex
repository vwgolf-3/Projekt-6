\clearpage
\subsection{Programmierschnittstellen}
\label{subsec:Programmierschnittstellen}

Auf der Leiterplatte des PartyMixer's gibt es zwei Komponenten, welche programmiert werden müssen. Der Mikrocontroller und das WiFi-Modul. Um diese zu programmieren, braucht es eine entsprechende Schnittstelle, welche im Falle des Partymixers mit einer USB-B-Schnittstelle realisiert wird.

Die USB-B-Schnittstelle benötigt nur zwei Kommunikationsleitungen (D+ und D-). Die zu programmierenden Komponenten (ESP32 und ATMega2560) benötigen zusätzliche Steuerleitungen um in einen Programmiermodus zu kommen und statt einem differenziellen Verfahrens ein serielles Verfahren. Deswegen wird ein USB-UART-Converter verwendet, welcher das Signal wandelt und die Steuerleitungen zur Verfügung stellt. \cite{zenkner_usb_2014}

Die beiden Programmierschnittstellen (ATMega2560 und ESP32) benötigen unterschiedlich viele Steuerleitungen, da sie sich im Verfahren zum Aufruf des Download-Boot-Modus unterscheiden. Im Anhang Kapitel \ref{Appendix:Handshake_uC} und \ref{Appendix:Handshake_ESP} wird dargestellt, welche Leitungen für das jeweilige Flash-Interface benötigt werden. Die Signalfolge, welche angelegt wird um den Programmier-Modus zu starten, wird auch Handshake genannt.
%Dieser wird in den Kapiteln \ref{subsubsec:Handshake_ATMega2560} und \ref{subsubsec:Handshake_ESP32} beschrieben. In Kapitel \ref{subsubsec:USB-B} wird dann das Schema beschrieben.
%Die USB-B-seitige Schnittstelle wird an den Computer angeschlossen und muss nicht häher betrachtet werden.

\subsubsection{Handshake ATMega2560}\label{subsubsec:Handshake_ATMega2560}

Der Handshake zwischen Computer und ATMega2560 ist einfacher zu verstehen als der Handshake zwischen Computer und ESP32. Beim ATMega2560 wird jedes Mal, nachdem der Mikrocontroller neu gestartet wird, der Bootloader aufgerufen. Deswegen reicht es für die Übermittlung des Programmcodes die Reset-Leitung auf 0V zu ziehen. Dies wird erreicht, indem der wiring-Programmer verwendet wird, welcher auf den verwendeten Bootloader angepasst ist und vor dem Hochladen die DTR-Leitung toggelt. Nachdem das Programmiertool AVRdude die Device-Signatur (0x1E9801) verifiziert hat, sendet es das kompilierte HEX-File an den ATMega2560. Mehr zum Bootloader in Kapitel \ref{subsubsec:Inbetriebnahme Bootloader}.

%Um die Daten hochladen zu können, muss sichergestellt werden, dass avrdude mit dem stk500v2 programmer hochlädt und die DTR-Leitung toggelt, bevor der Programmiervorgang stattfindet. Die DTR-Leitung hängt über einen Kondensator an der Reset-Leitung und zieht diese auf GND, womit der Bootloader des ATMega2560 aktiv wird. Deswegen wird beim Hochladen in AVRdude als programming-id der \textit{wiring}-programmer angegeben, sichtbar in Kapitel \ref{Appendix:AVR_STK500} (-c wiring).

\subsubsection{Handshake ESP32}\label{subsubsec:Handshake_ESP32}
Nach einem Neustart des ESP32 werden die Zustände der Strapping-Pins gelesen. Anhand dieser Zustände werden die Grundzustände des ESP32 gesetzt, bevor der Programmcode gestartet wird. Anhand der Strapping-Pins wird auch der Download-Boot-Modus gestartet. Mit einem Handshake zwischen Computer und ESP32 wird genau dies erreicht. Das ESP32 wird neu gestartet und der Download-Boot-Modus gesetzt.
Um den Handshake zwischen Computer und ESP32 zu verstehen, muss zuerst Tabelle \ref{tab:Einfluss_Pins_auf_Boot_Modus} betrachtet werden, worin die Strapping-Pins aufgelistet sind und welchen Einfluss diese auf denn Boot- oder Download-Modus haben. Aufgrund der defaultmässigen Pull-up und -down Widerstände kann aus dieser interpretiert werden, dass wenn U0TXD, IO2 und IO5 ''floating'' sind, IO0 den Boot-Modus bestimmt.

\begin{table}[H]
\center
\begin{tabular}{|l|c|c|c|}
\hline
\multicolumn{4}{|c|}{\textbf{Boot-Mode Konfiguration}}\\
\hline
\textbf{Pin} & \textbf{Default} & \textbf{Boot} & \textbf{Download} \\
\hline
IO0 & 1 & 1 & 0 \\
\hline
U0TXD & 1 & 1 & Don't care \\
\hline
IO2 & 0 & Don't care & 0 \\
\hline
IO15 & 1 & Don't care & Don't care \\
\hline
IO5 & 1 & 1 & Don't care \\
\hline
\end{tabular}
\caption{Wenn U0TXD, IO2, IO5 floating sind, bestimmt IO0 den Boot-Modus.}
\label{tab:Einfluss_Pins_auf_Boot_Modus}
\end{table}