\newpage
\subsection{Mikrocontroller}
\label{subsec:Inbetriebnahme_Mikrocontroller}

Um das Anwenderprogramm auf dem Mikrocontroller (\textmu C) speichern zu können, ist es am angenehmsten, wenn dies direkt aus der Programmierumgebung geschehen kann. Als Programmierumgebung wird aufgrund des AVR-Chips die Software Atmel Studio 7.0 ausgewählt.

Atmel Studio kompiliert den geschriebenen C Code in Maschinencode und schreibt diesen in ein HEX-File. Das HEX-File wird von einem Programmiertool namens AVRdude hochgeladen.\cite{verschiedene_autoren_avrdude_2019}


Damit der Mikrocontroller sich Programmieren lässt, müssen einige Grundeinstellungen vorgenommen werden. Dazu gehört das Setzen der Fuse- und Lock-Bits sowie das Schreiben des Bootloaders. Eine detailierte Beschreibung, wie diese gesetzt wurden, wird im Anhang Kapitel \ref{Appendix:Inbetriebnahme_uC} erklärt. Aus der Beschreibung folgt für die Fuse- und Lock-Bits die Einstellungen gemäss Tabelle \ref{tab:Fuse_und_Lock-Bits}.

\begin{table}[h!]
\center
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Extended} & \textbf{High} & \textbf{Low} & \textbf{Lock}\\
\hline
0xFF & 0xD0 & 0xF7 & 0xCF\\
\hline
\end{tabular}
\caption{Tabelle Fuse- und Lock-Bits.}
\label{tab:Fuse_und_Lock-Bits}
\end{table}

Das Setzen der Fuse- und Lock-Bits sowie das brennen des Bootloaders kann mit einem AVR MKII Programmer in Atmel Studio gemacht werden. Alternativ gibt es einen Weg, den USB-Treiber (Atmega16U2) eines Arduino Uno mit einer entsprechenden Firmware zu laden, sodass dieser als Programmer verwendet werden kann. Für die Inbetriebnahme des Mikrocontrollers wurde der Alternativweg gewählt. Eine ausführliche Anleitung findet sich auf \textit{instructables.com}. \cite{vidmofollow_turn_2017}

Von seitens Software muss AVRdude in Atmel Studio eingebunden werden, was im folgenden Kapitel erklärt wird.

\subsubsection{AVRdude in Atmel Studio einbinden}\label{subsubsec:avrdude_in_atmelstudio_einbinden}

Von \textit{http://savannah.gnu.org/} kann eine Datei heruntergeladen welche \textcolor{blue}{avrdude-6.3-mingw32.zip} heisst. Der gleichnahmige Ordner wird im Ordner \textcolor{blue}{C:\textbackslash Tools} gespeichert. \cite{savannahgnuorg_index_2016}

Nachdem dies gemacht wurde, wird in AtmelStudio der Reiter ''\textcolor{blue}{Tools\textrightarrow External Tools}'' ausgewählt und ein neues Tool hinzugefügt. Im Falle des Atmega2560 geben wir die Commands gemäss Tabelle \ref{tab:AVRdude_commands} ein:

\begin{table}[h!]
\center
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
Title & : & Cocktailmixer \\
\hline
Command & : & C:\textbackslash Tools\textbackslash avrdude-6.1-mingw32\textbackslash avrdude.exe \\
\hline
Arguments: & : & -D -P \textcolor{red}{ COMx} -p ATMEGA2560 -c wiring -b 115200 -U flash:w:\$(TargetDir)\$(TargetName).hex:i\\
\hline
\end{tabularx}
\caption{AVRdude Commands}
\label{tab:AVRdude_commands}
\end{table}

Der entsprechende \textcolor{red}{ COMx}-Port des zu flashenden Gerätes (Atmega2560) muss mit dem Geräte-Manager ermittelt werden. \cite{meier_mc1-skript_2017}

Nun kann aus Atmel Studio das kompillierte HEX-File hochgeladen werden.
\newpage
Folgende Schritte wurden befolgt:

\begin{enumerate}
\item Als Erstes wurden die Fuse-Bits gesetzt. Dies geschah über den Reiter:\newline
\textcolor{blue}{AtmelStudio \textrightarrow Tools \textrightarrow Device programming \textrightarrow Fuses} (siehe Abbildung \ref{fig:AtmelStudio_Fuses}) \newline
Es wurde darauf geachtet, dass der AVR mkII ausgewählt wurde und der Gerätecode des Atmega2560 ausgelesen werden konnte.\newline

\item Als Zweites wurde der Bootloader installiert. Dies geschah unter:\newline
\textcolor{blue}{AtmelStudio \textrightarrow Tools \textrightarrow Device programming \textrightarrow Memory} (siehe Abbildung \ref{fig:AtmelStudio_Program_Bootloader}) \newline
Hier wird ein stk500v2-BL verwendet.\newline
%Dies kann aber auch abweichen. (Entsprechende Anpassungen nötig, nicht Teil dieses Projektes.)\newline
\item Als Drittes wurden die Lock-Bits gesetzt unter:\newline
\textcolor{blue}{AtmelStudio \textrightarrow Tools \textrightarrow Device programming \textrightarrow Lock-Bits} (siehe Abbildung \ref{fig:AtmelStudio_Locks})\newline
Diese sollten nicht mehr geändert werden. Bei jedem Brennen des BL wieder zu setzen.\newline
%\item Ggf. USB-Firmware installieren auf dem USB-UART-Converter. (Nicht Teil dieses Projektes.)\newline
\item Mikrocontroller mit der kompillierten Software (Cocktailmixer.HEX) programmieren.\newline
\textcolor{blue}{AtmelStudio \textrightarrow Tools \textrightarrow Cocktailmixer}\newline
%Alternativ direkt mit ISP-Programmer wie in Schritt 2 (ohne Bootloader, Programmcode an start-Vektor des \textmu Cs.):\newline
%\textcolor{magenta}{z.B C:\textbackslash Users\textbackslash DaU\textbackslash Software\textbackslash Cocktailmixer\textbackslash Cocktailmixer\textbackslash Debug\textbackslash Cocktailmixer.HEX}
\end{enumerate}

Wird der Mikrocontroller per Reset-Button neu gestartet, dauert es aufgrund des Bootloaders 2s, bis der Programmcode gestartet wird. Während dieser Zeit wartet der Bootloader auf einkommende Daten, welche auf den Flash-Speicher geschrieben werden sollen. Danach startet das Programm, sollten keine Daten kommen.

Sämtliche Tabellen aus dem Datenblatt und Screenshots aus Programmierumgebung, welche mit dem Setzen der Fuse- und Lock-Bits oder Programmierung des \textmu C zusammenhängen, sind im Anhang Kapitel \ref{Appendix:Inbetriebnahme_uC} angefügt.